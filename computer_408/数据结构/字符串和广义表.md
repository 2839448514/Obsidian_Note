字符串简称为串，是n(n>0)个字符的一个有限序列，通常记为$S="a_0,a_1,a_2···a_{n-1}"$。其中**S是串名**，用**双引号引起来的是串值。**

- 长度为0的串是空串，空白串的长度不为0，除了结束符外还包括空格符。
- 空串是任意串的子串，任意串是他自身的子串。除了串本身外，他的任意一个子串都是他的真子串。
- 在C++中可以使用`#include<string>`来使用字符串操作。

## KMP算法

kmp算法又称B-F算法。其中比较时，主串一直往前移动，不回退，而子串通过`next[i]`中计算的值选择回退到子串的第几个字符。由于在c和c++数据结构两本书上方法不同，这里我们查看三种方法计算`next[i]`数组。

> [!NOTE] 匹配过程解析
> 当主串与子串匹配时，如果在第n个字符匹配失败，则会在n-1个字符里面查找有没有最长公共前后缀，如果有，就把子串的前缀移动到后缀位置，主串不变，继续遍历。

### 1. c语言版本计算`next[i]`数组

该方法计算`next[i]`数组为：

$$
 \text{next}[j] = \begin{cases} 0 & \text{当 } j = 1 \text{ 时} \\ \max\{k \mid 1 < k < j \text{ 且 } p_1 \cdots p_{k-1} = p_{j-k+1} \cdots p_{j-1}\} & \text{当此集合不空时} \\ 1 & \text{其他情况} \end{cases} 
$$

 **通俗解释**

1. **`next[j]` 是什么？**
    - 它表示模式串中从第一个字符到第 j−1 个字符这一段，**最长的“前后缀”长度**。
    - **前后缀**：子串既是这段开头的前缀，又是结尾的后缀，但不能是整段本身。
2. **怎么算 `next[j]`？**
    - 如果 j=1，第一个字符前面没有内容，所以直接定义为`next[1]=0`。
    - 对于 j>1 的情况：
        - 从字符串开头到j-1个字符中全部字符，寻找最长前后缀：
            - 如果找到，`next[j]` 就等于这段的长度。
            - 如果找不到，`next[j]` 默认值是 1（表示没有前后缀）。

#### 举例 模式串为：`p = abaabcac`

| **位置 (j)** | **子串 (1 到 j-1)** | **最长前后缀** | **长度 (next[j])** | **说明**                  |
| ---------- | ---------------- | --------- | ---------------- | ----------------------- |
| 1          | 无                | 无         | 0                | 第一个字符无前后缀               |
| 2          | `a`              | 无         | 1                | 前面只有一个字符，无前后缀           |
| 3          | `ab`             | 无         | 1                | 无法找到既是前缀又是后缀的子串         |
| 4          | `aba`            | `a`       | 2                | 前缀 `a` 等于后缀 `a`，长度为 1   |
| 5          | `abaa`           | `a`       | 2                | 前缀 `a` 等于后缀 `a`，长度为 1   |
| 6          | `abaab`          | `ab`      | 3                | 前缀 `ab` 等于后缀 `ab`，长度为 2 |
| 7          | `abaabc`         | 无         | 1                | 无法找到既是前缀又是后缀的子串         |
| 8          | `abaabca`        | `a`       | 2                | 前缀 `a` 等于后缀 `a`，长度为 1   |

#### 最终KMP算法
