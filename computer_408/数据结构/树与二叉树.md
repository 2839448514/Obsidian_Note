## 定义（树）

树是n（n>=0）个结点的有限集。当n = 0时，称为空树。在任意一棵非空树中应满足：

1. 有且仅有一个特定的称为根的结点。
2. 当n>1时，其余节点可分为m（m>0）个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一棵树，并且称为根的子树。
**空树也是树**。

### 基本概念

- **根节点**：树结构中的最顶端节点，它没有父节点。
- **分支节点（内部节点）**：不是树的根节点也不是叶子节点的任何节点。这些节点至少有一个子节点和一个父节点。
- **叶子节点（终端节点）**：没有子节点的节点，它们位于树的最底层。
- **空树**：一个不包含任何节点的树。
- **子树**：以树中任意节点为根节点形成的树，包括该节点及其所有后代。
- **节点的度**：一个节点拥有的子节点数目。这是指直接连接到该节点的孩子节点的数量。
- **树的度**：树中所有节点的度的最大值。
- **节点的深度（层次）**：（**从上往下数**）从根节点到当前节点的路径上的边数。。
- **节点的高度**：（**从下往上数**）从当前节点到其最远叶子节点的最长简单路径上的边数。所有叶子节点的高度为1。
- **树的高度（深度）**：树中所有节点高度的最大值，即从根节点到最远叶子节点的最长路径上的边数。

### 树的性质

- **==节点数=总度数+1。==**
- **边数=节点数−1**
- **满m叉树节点编号为 i 的第 k 个孩子节点编号为$(i-1)*m+k+1（1\leq k\leq m)$**
- **非空二叉树的叶子节点数等于度为 2 的节点数加1 ，即 $n_0=n_2+1$** 
- **度为m的树和m叉树：**

| 度为m的树              | m叉树              |
| ------------------ | ---------------- |
| 任意节点的度≤m（最多m个孩子）   | 任意节点的度≤m（最多m个孩子） |
| 至少有一个节点的度=m（有m个孩子） | 允许所有节点的度都\<m     |
| 一定是非空树，至少有m+1个节点   | 可以是空树            |
|                    |                  |

- **度为m的树第i层至多有$m^{i-1}$个节点（i≥1）。m叉树第i层至多有$m^{i-1}$个节点（i≥1）**
- **高度为h 的 m叉树 最多有 $\frac{m^{h} - 1}{m - 1}$ 个节点，特殊情况下 m = 1 时，最多有 h 个节点。最少有$h+m-1$个节点**。
- 具有n个节点的m叉树的最小高度为$h = \left\lceil \log_m \left( (m - 1) \cdot n + 1 \right) \right\rceil$。
- 假设树的度是 d，节点数是 n，并且树尽可能地“平衡”，那么树的高度 h 会接近$\lceil \log_d n \rceil$，即树的高度是节点数的对数（以度为底）。
- 如果树是**链式结构**（也就是每个节点最多有一个子节点），那么树的高度就是节点数减去1。即最小高度为：$h_{\text{min}} = n - 1$ 其中 n 是节点数。
- 如果一棵度为m树有n个结点，，树的最大高度为$n-m+1$。
> [!NOTE] 已知一颗树的度和各节点的度求叶子结点
> 在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶子结点个数是（   ）。
> 解：先求总度数为122，加1后为节点数123，那么20+10+1+10+x=123，可得叶子结点为82。

## 定义（二叉树）

**二叉树**是树形数据结构的一种特殊类型，每个节点最多有两个子节点，通常被称为**左子节点**和**右子节点**。

> **给定 n 个节点，可以构成的不同结构的二叉树的个数（不考虑节点值的排列）为第 n 个卡塔兰数，记作 $C_n$​。卡塔兰数的递推公式为：$C_n = \frac{1}{n+1} \binom{2n}{n} = \frac{(2n)!}{(n+1)!n!}$**

> Cayley 定理给出了一个 n 个节点的树的数量，假设树是一个带有标记节点的无根树（即节点是有标签的）。Cayley 定理指出，**n 个节点的无根树有 $n^{n-2}$ 种**。$T(n) = n^{n-2}$
> 这个公式适用于节点是可标记的树结构，即每个节点都被唯一标识，可以区分每个节点。此时，节点之间的连接关系决定了树的形态。

### 特殊二叉树

#### ==**满二叉树**==

定义：一颗高度为h，只含有$2^{h}-1$个结点的二叉树。

1. 只有最后一层有叶子结点。
2. 不存在度为1的结点，
3. 按层序遍历从1开始编号，结点i的左孩子为$2i$，右孩子为$2i+1$，结点i的父节点为$floor(\frac{i}{2})$。

#### ==**完全二叉树**==

定义：完全二叉树是指除了最后一层外，其它各层的结点数都达到最大值，且最后一层的结点都集中在该层最左边的二叉树。

1. 只有最后两层有叶子结点。
2. **最多只有一个度为1的结点。**
3. 按层序遍历从1开始编号，结点i的左孩子为$2i$，右孩子为$2i+1$，结点i的父节点为$floor(\frac{i}{2})$。
4. $i≤floor(n/2)$为分支结点，$i≥floor(n/2)$为叶子结点。
5. 在一个完全二叉树中，如果总节点数为 n，则叶子节点的数量 L 可以通过下面的公式计算：$L=⌈n/2⌉$。

#### ==二叉排序树==

定义： **每个节点最多有两个子节点**。**左子树**的所有节点值都小于当前节点的值。**右子树**的所有节点值都大于当前节点的值。对于每个节点，左子树和右子树本身也必须是二叉排序树。

##### 特性：

- **查找操作**：由于树的结构特性，查找操作的时间复杂度通常为 $O(h)$，其中 h 是树的高度。在最好的情况下（树是平衡的），查找的时间复杂度为 $O(log_2n)$，其中 n 是节点数；在最坏的情况下（树变成链式结构时），时间复杂度为 $O(n)$。
- **插入操作**：插入操作的时间复杂度与查找相同。插入时，我们需要找到正确的位置，并将新节点插入到该位置。
- **删除操作**：删除节点时，有三种情况需要考虑：
    1. **删除叶子节点**：直接删除即可。
    2. **删除只有一个子节点的节点**：用该节点的子节点替代它。
    3. **删除有两个子节点的节点**：找到该节点的**中序后继**（右子树中最小的节点）或**中序前驱**（左子树中最大的节点），用其值替代当前节点的值，然后删除那个后继或前驱节点。

#### 平衡二叉树（AVL树）

定义：**平衡二叉树**的要求是：对于树中每一个节点，**左子树**和**右子树**的高度差的绝对值不超过1。即，假设某个节点的左右子树高度分别为 **h_left** 和 **h_right**，则满足：$|h_{\text{left}} - h_{\text{right}}| \leq 1∣$如果这个条件被满足，树就是**平衡的**。否则，它就是**不平衡的**。

##### 平衡化旋转

寻找最小非平衡子树进行旋转。

1. 右单旋转（LL型）
2. 左单旋转（RR型）
3. 先左后右双旋转（RL型）
4. 先右后左双旋转（LR型）
![[2.png]]

1. **右单旋转（LL型 - Left-Left Case）** 当新节点被插入到左子树的左子树时（即，不平衡发生在根节点的左侧，且是由左子树的左侧引起的），需要执行一次右单旋转来重新平衡树。

    ```
        A                        B
       / \     Right Rotate     / \
      B   T3   --------->      T1  A
     / \                           / \
    T1  T2                       T2  T3
    ```

2. **左单旋转（RR型 - Right-Right Case）** 当新节点被插入到右子树的右子树时（即，不平衡发生在根节点的右侧，且是由右子树的右侧引起的），需要执行一次左单旋转来重新平衡树。

    ```
        A                        B
       / \     Left Rotate     / \
      T1  B    --------->     A   T3
         / \                / \
        T2  T3            T1  T2
    ```

3. **先左后右双旋转（RL型 - Right-Left Case）** 

    ```
        A                C
       / \             /    \            
      T1  B     ->    A      B
         / \         / \    / \
        C  T4       T1  T2 T3  T4
       / \             
      T2  T3          
    ```

4. **先右后左双旋转（LR型 - Left-Right Case）**

    ```
        A                    C
       / \                  / \              
      B   T3               B   A
     / \      ----------> / \  / \
    T1  C               T1  T2 T3 T4
       / \                    
      T2  T3                  
    ```

每种旋转都会调整树的结构，以确保从任何节点出发到达其两个子树（如果存在）的最深叶节点的路径长度之差不超过1。这保证了树的高度尽可能小，从而保持了树的操作（查找、插入、删除）的时间复杂度为O(log n)。

### 基本性质

- 非空二叉树里面度为0，1，2的结点个数分别为$n_0$、$n_1$、$n_2$，则$n_0=n_2+1$（叶子结点比二分支结点多一个）。
- 二叉树的第i层最多有$2^{i-1}$个结点。
- 高度为h的二叉树最多有$2^h-1$个结点（满二叉树）。
- 对于具有 n 个节点的完全二叉树，其高度 h 为：$h = \left\lfloor \log_2(n) \right\rfloor+1$或$h = \left\lceil \log_2(n+1) \right\rceil$。
- 对于完全二叉树，可以由结点总数n推出度为0，1，2的结点个数$n_0$、$n_1$、$n_2$。
	$n_1$=0或1；
	$n_0=n_2+1\rightarrow n_0+n_2$一定为奇数。
	**若完全二叉树有$2k$个偶数结点，则一定有$n_1=1$,$n_0=k$,$n_2=k-1$。
	若完全二叉树有$2k-1$个偶数结点，则一定有$n_1=0$,$n_0=k$,$n_2=k-1$。**
- **具有n个节点的完全二叉树深为$log_2x+1$（其中x表示不大于n的最大整数）。**

### 二叉树的遍历

#### 代码实现

1. 先序遍历

```cpp
void preorder(TreeNode* root) {
  if (root == NULL) return;
  cout << root->val << " ";
  preorder(root->left);
  preorder(root->right);
}
```

2. 中序遍历

```cpp
void inorder(TreeNode* root) {
  if (root == NULL) return;
  inorder(root->left);
  cout << root->val << " ";
  inorder(root->right);
}
```

3. 后序遍历

```cpp
void postorder(TreeNode* root) {
  if (root == NULL) return;
  postorder(root->left);
  postorder(root->right);
  cout << root->val << " ";
}
```

#### 已知两个遍历，求第三个遍历

==**已知中序遍历和任意一个遍历，可以求得唯一确定的二叉树。**==

**Q：设一棵二叉树的先序序列： A B D F C E G H，中序序列： B F D A G E H C**

1. 已知前序遍历和中序遍历求后序遍历

 步骤：

1. **前序遍历与中序遍历的关系**：
    
    - 在前序遍历中，**第一个元素**是树的根节点。
    - 中序遍历中，**根节点左边的部分**是左子树的节点，**右边的部分**是右子树的节点。
2. **求解步骤**：
    
    - 从前序遍历中取出第一个元素作为根节点。
    - 找到根节点在中序遍历中的位置，这将中序遍历分成两部分：
        - 左边部分为左子树的节点。
        - 右边部分为右子树的节点。
    - 然后，递归地对左子树和右子树进行相同的操作。

1. 已知后序遍历和中序遍历求先序遍历

 步骤：

1. **后序遍历与中序遍历的关系**：
    
    - 后序遍历的**最后一个元素**是树的根节点。
    - 中序遍历中，**根节点左边的部分**是左子树的节点，**右边的部分**是右子树的节点。
2. **求解步骤**：
    
    - 从后序遍历中取出最后一个元素作为根节点。
    - 在中序遍历中找到根节点的位置，分割成左子树和右子树。
    - 然后递归地分别处理左子树和右子树，构建整个树。

### 线索二叉树

在**线索二叉树**中，**左子树指针**和**右子树指针**不仅用于指向子节点，还可以指向该节点的前驱节点和后继节点。具体地：

- 如果左子指针为空，表示该节点的左指针是**前驱节点的线索**。
- 如果右子指针为空，表示该节点的右指针是**后继节点的线索**。

#### 线索二叉树的构造

**对于线索二叉树来说，存在先序线索二叉树，中序线索二叉树，后序线索二叉树。如果一个结点没有左右孩子，那么可以在这个二叉树的遍历里面查找他的前驱和后继，左指针指向他的前驱，右指针指向他的后继，就是他的线索二叉树，而使用哪个遍历方式构造的就是哪个线索二叉树。**

### 二叉树和森林之间的转换

#### 二叉树转森林

**求解过程**：

- 遍历二叉树的每一个结点p。
- 对于每一个结点p（即是左孩子的结点），找到它所有的右孩子。
- 将这些右孩子与其各自的父结点断开，并将它们与结点p的父结点重新连接，成为父结点的右孩子。
- 这样，左孩子及其右孩子会形成独立的树，最终得到森林。

**步骤**：

1. 遍历二叉树的每个结点。
2. 对于每个结点p，执行以下操作：
    - 如果p是左孩子，找到它所有的右孩子。
    - 将这些右孩子与父结点断开，重新连接到结点p的父结点的右子树。
3. 最终，所有的左孩子及其右孩子会独立成一棵树，形成森林。

---

#### 2. 森林转二叉树

**求解过程**：

- 在所有单独的树里，遍历每一个有孩子的结点。
- 如果某结点的孩子数为1，则该孩子作为它的左子树。
- 如果某结点的孩子数大于1，则将它的所有孩子按顺序连接，第一个孩子为左子树，第二个及以后的孩子成为右子树的右孩子，形成一个链式结构。
- 最后，将所有树的根结点连起来，形成一个二叉树，右边的根结点成为左边根结点的右孩子。

**步骤**：

1. 遍历森林中的每棵树。
2. 对每个树根结点，检查它的孩子：
    - 如果孩子数为1，将这个孩子作为左子树。
    - 如果孩子数大于1，将所有孩子按顺序连接，第一个孩子为左子树，后续孩子按右子树的右孩子依次连接。
3. 将所有树的根结点按顺序连接，形成一个二叉树。每个树的根结点与前一个树根连接时，成为它的右子树。

### 哈夫曼树
