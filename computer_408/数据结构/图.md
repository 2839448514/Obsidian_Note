## 定义

图 是一个二元组 $G = (V(G), E(G))$。其中 $V(G)$ 是 **非空点集** ，对于$V$ 中的每个元素，我们称其为 **顶点 (vertex)** 或 **节点 (node)**，简称 **点**；$E(G)$ 为 $V(G)$ 各结点之间边的集合，称为 **边集**。常用 $G = (V, E)$ 表示图。其中

$$
\begin{aligned}
G_2 &= (V, E) \\
V_2 &= \{A, B, C, D, E\} \\
E_2 &= \{(A, B), (B, D), (B, E), (C, D)\}
\end{aligned}
$$

## 图的类型

图有多种，包括 **无向图**，**有向图**，**无向网**，**有向网**  等。

### 无向图

- **顶点的度**：顶点的度是指依附于该顶点的边的条数，记为TD(v)。
- **==无向图的全部顶点的度的和等于边数的2倍。==**

### 有向图

- **入度**：以顶点v为终点的有向边的数目，记为ID(v)。
- **出度**：以顶点v为起点的有向边的数目，记为OD(v)。
- **顶点的度等于出度与入度之和，一个顶点的入度与出度相同。**。

## 基本概念

- **简单图**：不存在重复的边，不存在顶点到自身的边。
- **多重图**：某两个节点之间的边数多于一条，又允许顶点通过一条边与自己关联。
- **路径**：顶点$V_p$到顶点$V_q$之间的一条路径。
- **回路(环)**：第一个顶点与最后一个顶点相同。
- **简单路径**：在一个路径中，顶点不重复出现的路径称为简单路径。
- **简单回路**：除了第一个顶点和最和一个顶点外，其余顶点不重复出现称为简单回路。
- **无向图连通**：无向图中，如果从顶点v到顶点w有路径存在，那么v和w是连通的。
- **有向图强连通**：有向图中，如果从顶点v到顶点w和从顶点w到顶点v之间都有路径，那么这两个顶点是**强连通**的。
- **连通图和非连通图**：如果图中任意两个顶点都是连通的，那么该图为连通图，否则为非连通图。==如果该图为连通图，最少有$n-1$条边，如果为非连通图，最多有$C\binom{2}{n-1}$条边。==
- **强连通图**：如果图中任意一堆顶点都是强连通的，那么该图为强连通图。==如果对于n个顶点的有向图G，图G是强连通图，则最少有n条边。==
- **连通分量**：对于一个无向图，连通分量是指图中的一个最大连通子图，其中任意两个顶点之间都存在一条路径。
- **无向完全图**：无向图中任意两个顶点之间都存在图。
- **有向完全图**：有向图中任意两个顶点之间都存在方向相反的两条弧。

## 基本求解题目

- **连通分量**：寻找图中有多少个未连通的的区域，那么连通分量就是多少。

## 图的存储方式

### 1. 邻接矩阵 (Adjacency Matrix)

邻接矩阵是一个二维数组，用来表示图中顶点之间的连接关系。对于一个有 nnn 个顶点的图，邻接矩阵是一个 $n \times n$ 的矩阵，其中矩阵的元素表示顶点之间的连接情况。

- **无向图**：如果存在一条边连接顶点 i 和顶点 jjj，则矩阵中的元素 $matrix[i][j]$ 和 $matrix[j][i]$都为1（或者表示边的权重的值）。
- **有向图**：如果有一条从顶点 iii 指向顶点 jjj 的有向边，则矩阵中的元素 $matrix[i][j]$ 为1（或者表示边的权重的值）。

### 2. 邻接表 (Adjacency List)

邻接表是另一种常见的图的存储方式，它通过一个数组（或链表）来存储每个顶点的邻接点（即与该顶点相连的边的目标顶点）。

- **无向图**：每条边都需要在两个顶点的邻接表中分别存储。
- **有向图**：每条边只需要在起点的邻接表中存储。

| 存储方式 | 时间复杂度                 | 空间复杂度    | 优点            | 缺点               |
| ---- | --------------------- | -------- | ------------- | ---------------- |
| 邻接矩阵 | $O(1)$查找边             | $O(n^2)$ | 查找边高效，适用于稠密图  | 空间浪费，稀疏图效率低      |
| 邻接表  | $O(\text{deg}(v))$查找边 | $O(n+m)$ | 空间效率高，适用于稀疏图  | 查找边较慢，遍历不如邻接矩阵高效 |
| 十字链表 | $O(1)$查找边             | $O(n+m)$ | 适合有向图，支持反向边操作 | 实现复杂，空间较大        |
| 边集数组 | $O(m)$ 查找边            | $O(m)$   | 实现简单，空间少      | 查找边效率低，遍历边不高效    |

### 表示

1. 邻接矩阵的表示

|     | a   | b   | c   | d   |
| --- | --- | --- | --- | --- |
| a   | 0   | 1   | 0   | 0   |
| b   | 0   | 0   | 1   | 1   |
| c   | 0   | 1   | 0   | 0   |
| d   | 1   | 0   | 0   | 0   |

2. 邻接表的表示

```plaintext
0: [a,·]->[1,^]
1: [b,·]->[2,·]->[3,^]
2: [c,·]->[1,^]
3: [d,·]->[0,^]
```

> [!NOTE] 注意
> **邻接表**指向的是一个顶点的所有**出度**节点，即从当前顶点出发的边所指向的其他顶点。而**逆邻接表**则是指向一个顶点的所有**入度**节点，即指向当前顶点的所有边的起点。

## 图的基本操作

## 广度优先搜索与深度优先搜索

### BFS

BFS为广度优先遍历，即将队列中的第一个元素指向的所有节点全部添加到队列中并标记该元素，之后把队列的第一个元素出队，每次循环，直到搜索到指定元素。

```c++
#include <iostream>
#include <algorithm>
#include<queue>
using namespace std;
struct node {
    int x, y;
};
int mp[5][5]{{0, 1, 0, 1, 1},
             {0, 0, 1, 0, 1},
             {0, 0, 0, 0, 0},
             {1, 0, 0, 1, 0},
             {0, 1, 0, 0, 0}};
int vis[10][10]{};
int dir[4][2] = {{0,  1},
                 {0,  -1},
                 {1,  0},
                 {-1, 0}};
int main() {
    queue<node> q;
    q.push({0, 0});
    vis[0][0] = 1;
    while (!q.empty()) {
        node now = q.front();
        cout << "当前坐标" << now.x << " " << now.y << endl;
        q.pop();
        if (now.x == 4 && now.y == 4) {
            cout << "YES" << endl;
            return 0;
        }
        for (int i = 0; i < 4; i++) {
            int tx = now.x + dir[i][0], ty = now.y + dir[i][1];
            if (tx < 0 || tx > 4 || ty < 0 || ty > 4) {
                continue;
            }
            node next = {tx, ty};
            if (vis[tx][ty] == 0 && mp[tx][ty] == 0) {
                vis[tx][ty] = 1;
                q.push(next);
            }
        }
    }
    return 0;
}
```

### DFS

BFS为深度优先搜索，即将首先遍历到的元素压入栈中并标记该节点，之后再寻找栈中顶部节点指向的节点，若为寻找到没有被标记的指向节点，则推出栈，以此循环，直到找到指定节点。

	下面的代码使用递归来模拟栈的操作；

```c++
#include <iostream>
#include <algorithm>
using namespace std;
struct node {
    int x, y;
};
int mp[5][5]{{0, 1, 0, 1, 1},
             {0, 0, 1, 0, 1},
             {0, 0, 0, 0, 0},
             {1, 0, 0, 1, 0},
             {0, 1, 0, 0, 0}};
int vis[10][10]{};
int dir[4][2] = {{0,  1},
                 {0,  -1},
                 {1,  0},
                 {-1, 0}};
void DFS(node head) {
    cout<<"当前坐标"<<head.x<<" "<<head.y<<endl;
    if (head.x == 4 && head.y == 4) {
        cout << "YES" << endl;
    }
    for (int i = 0; i < 4; i++) {
        int tx = head.x + dir[i][0], ty = head.y + dir[i][1];
        if (tx < 0 || tx > 4 || ty < 0 || ty > 4) {
            continue;
        }
        node next = {tx, ty};
        if (mp[tx][ty] == 0 && vis[tx][ty] == 0) {
            vis[tx][ty] = 1;
            DFS(next);
            vis[tx][ty] = 0;
        }
    }
}
int main() {
    node head = {0, 0};
    vis[0][0] = 1;
    DFS(head);
    return 0;
}
```

### 深度优先生成树和广度优先生成树

假设有以下的邻接矩阵：

|     |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|  1  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  1  |  0  |
|  2  |  0  |  0  |  1  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |
|  3  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  1  |  0  |  0  |
|  4  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  1  |  0  |
|  5  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  1  |
|  6  |  1  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  7  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |
|  8  |  1  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  1  |  0  |
|  9  |  0  |  0  |  0  |  0  |  1  |  0  |  1  |  0  |  0  |  1  |
| 10  |  1  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |

1. 深度优先生成树

**深度优先搜索栈操作步骤**

```plaintext
步骤 1: [1]            // 节点 1 压栈
步骤 2: [1, 7]         // 节点 7 压栈
步骤 3: [1, 7, 3]      // 节点 3 压栈
步骤 4: [1, 7, 3, 4]   // 节点 4 压栈
步骤 5: [1, 7, 3, 4, 5] // 节点 5 压栈
步骤 6: [1, 7, 3, 4, 5, 6] // 节点 6 压栈
步骤 7: [1, 7, 3, 4, 5, 6, 2] // 节点 2 压栈
步骤 8: [1, 7, 3, 4, 5, 6] // 弹出节点 2，回到节点 6
步骤 9: [1, 7, 3, 4, 5] // 弹出节点 6，回到节点 5
步骤 10: [1, 7, 3, 4, 5, 10] // 节点 10 压栈
步骤 11: [1, 7, 3, 4, 5] // 弹出节点 10，回到节点 5
步骤 12: [1, 7, 3, 4]   // 弹出节点 5，回到节点 4
步骤 13: [1, 7, 3, 4, 9] // 节点 9 压栈
步骤 14: [1, 7, 3, 4]   // 弹出节点 9，回到节点 4
步骤 15: [1, 7, 3]     // 弹出节点 4，回到节点 3
步骤 16: [1, 7, 3, 8]  // 节点 8 压栈
步骤 17: [1, 7, 3]     // 弹出节点 8，回到节点 3
步骤 18: [1, 7]        // 弹出节点 3，回到节点 7
步骤 19: [1]           // 弹出节点 7，回到节点 1
步骤 20: []            // 弹出节点 1，遍历完毕
```

2. 深度优先生成树

```plaintext
步骤 1: [1]            // 节点 1 入队，开始搜索节点 7 和 9  
步骤 2: [1, 7, 9]      // 节点 7 和 9 入队，开始从队列中依次处理节点  
步骤 3: [7, 9]         // 节点 1 出队，开始搜索节点 3 和 10  
步骤 4: [9, 3, 10]     // 节点 3 和 10 入队，节点 7 已处理完成，出队  
步骤 5: [9, 3, 10]     // 节点 9 出队，开始搜索节点 5，节点 9 已处理完成，出队  
步骤 6: [3, 10, 5]     // 节点 5 入队，开始从队列中处理节点 3  
步骤 7: [10, 5, 4, 8]  // 节点 4 和 8 入队，节点 3 已处理完成，出队  
步骤 8: [5, 4, 8, 6]   // 节点 6 入队，节点 10 已处理完成，出队  
步骤 9: [4, 8, 6]      // 节点 4 出队，未搜索到目标节点，回到队列  
步骤 10: [8, 6]        // 节点 8 出队，未搜索到目标节点，回到队列  
步骤 11: [6]           // 节点 6 出队，开始搜索节点 2  
步骤 12: [2]           // 节点 2 入队，节点 6 已处理完成，出队  
步骤 13: []            // 节点 2 出队，未搜索到目标节点，回到队列，遍历完毕
```

### 最小生成树

[视频连接](https://www.bilibili.com/video/BV1wG411z79G?t=6.3)

在一个无向图中搜索一颗n个节点的树（n-1条边），而且这棵树的边权值最小。

#### 1. Prim（普利姆算法）

先从图中随机选取一个节点，在其他没有被标记的点里面寻找距离标记的点最近的点并标记他，如果有多个最近节点的权值相同，则可以随机选取一个，以此循环，直到选取所有点。

- Prim算法的效率与节点有关

#### 2. Kruskal（克鲁斯科尔算法）

先从图中选取权值最小的边并标记这条边，之后一直寻找未被标记的权值最小的边，选取过程中不能形成环，直到所有节点都被连接。

### 最短路径

#### 求出某个顶点到其他各顶点间的最短路径（dijkstra算法）

假如有以下图：

![[1.png]]

| 操作顺序 |     |    1    |     2     |      3      |      4      |       5       |        6        |
| ---- | :-: | :-----: | :-------: | :---------: | :---------: | :-----------: | :-------------: |
| 6    |  b  | 15(a,b) |  15(a,b)  |   15(a,b)   |   15(a,b)   |    15(a,b)    |     15(a,b)     |
| 1    |  c  | 2(a,c)  |     -     |      -      |      -      |       -       |        -        |
| 4    |  d  | 12(a,d) |  12(a,d)  | 11(a,c,g,d) | 11(a,c,g,d) |       -       |        -        |
| 3    |  e  |    ∞    | 10(a,c,e) |  10(a,c,e)  |      -      |       -       |        -        |
| 2    |  f  |    ∞    | 6(a,c,f)  |      -      |      -      |       -       |        -        |
| 5    |  g  |    ∞    |     ∞     | 16(a,c,f,g) | 16(a,c,f,g) | 14(a,c,f,d,g) |        -        |
|      | 终点集 |  {a,c}  |  {a,c,f}  |  {a,c,f,e}  | {a,c,f,e,d} | {a,c,f,e,d,g} | {a,c,f,e,d,g,b} |

**算法过程**：从第一个节点开始添加到路径里面，计算每一个节点到该路径的距离，之后从计算的距离里面找出距离最短的节点将该节点添加到路径里面，下次计算其他节点到该路径的距离，以此循环，直到把所有节点全部添加到路径里面。

#### 求出每个顶点间的最短路径（Floyd算法）

1. 方法一：每次以一个顶点未源点，执行Dijkstra算法n次。时间复杂度：$O(n^3)$
2. 方法二：弗洛伊德算法。时间复杂度：$O(n^3)$
算法思想：逐个顶点试探，从$V_i$到$V_j$的所有存在路径，选出一条最短的路径。
==**算法步骤**：==
1. 初始时设置一个n阶的方阵，令其对角线元素为0，如果存在一条弧$<v_i,v_j>$，则对应元素为权值，否则为∞。
 2. 逐步的在原来的路径里面添加中间节点，如果加入的中间节点使其路径变短，那么修改它，否则，不变，所有顶点试探完毕后，结束。
假设图为：

|     | A   | B   | C   |
| --- | --- | --- | --- |
| A   | 0   | 4   | 11  |
| B   | 6   | 0   | 2   |
| C   | 3   | ∞   | 0   |

按照以上邻接矩阵可以写出以下路径：

|     | AB  | AC  | -   | 0   | 4   | 11  |
| --- | --- | --- | --- | --- | --- | --- |
| BA  |     | BC  | -   | 6   | 0   | 2   |
| CA  |     |     | -   | 3   | ∞   | 0   |

之后加入顶点，例如加入A顶点，寻找有没有其他顶点到某个顶点的距离变小，则修改它。例如，在下面的顶点里加入A顶点没有路径变小，所以不变，但是加入A顶点后有了从C到B的路径，所以加入CAB：

|     | AB  | AC  | -   | 0   | 4   | 11  |
| --- | --- | --- | --- | --- | --- | --- |
| BA  |     | BC  | -   | 6   | 0   | 2   |
| CA  | CAB |     | -   | 3   | 7   | 0   |

之后加入顶点，例如加入B顶点，从A顶点到C顶点的路径变小，修改为ABC；

|     | AB  | ABC | -   | 0   | 4   | 6   |
| --- | --- | --- | --- | --- | --- | --- |
| BA  |     | BC  | -   | 6   | 0   | 2   |
| CA  | CAB |     | -   | 3   | 7   | 0   |

之后加入顶点，例如加入C顶点，从B顶点到A顶点的路径变小，修改为BCA；

|     | AB  | ABC | -   | 0   | 4   | 6   |
| --- | --- | --- | --- | --- | --- | --- |
| BCA |     | BC  | -   | 5   | 0   | 2   |
| CA  | CAB |     | -   | 3   | 7   | 0   |

### 拓扑排序

- **拓扑排序**要解决的问题是如何给一个有向无环图的所有节点排序。==**如果一个有向图中有回路（包含环），则无法输出拓扑排序。**==

**含义**： 在一个 DAG（有向无环图） 中，我们将图中的顶点以线性方式进行排序，使得对于任何的顶点u到v的有向边 `(u,v)`, 都可以有u在v的前面。还有给定一个 DAG，如果从i 到j有边，则认为j依赖于i。如果i到j有路径（i可达j），则称j间接依赖于i。**拓扑排序**的目标是将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点。

#### 得到拓扑排序

1. 从图中选择一个入度为零的点。
2. 输出该顶点，从图中删除此顶点及其所有的出边。

重复上面两步，直到所有顶点都输出，拓扑排序完成，或者图中不存在入度为零的点，此时说明图是有环图，拓扑排序无法完成，陷入死锁。
