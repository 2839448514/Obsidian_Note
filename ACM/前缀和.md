## 前缀和查找有相同数字的最长区间

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>


using namespace std;

typedef long long ll;

unordered_map<int, int> prefixDiff;
ll r, c;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n;
    cin >> n;
    vector<int> a(n + 1);
    vector<int> qz(n + 1, 0);

    for (int i = 1; i <= n; i++)
    {
        ll x;
        cin >> x;
        a[i] = x == 1 ? 1 : -1;
        qz[i] = qz[i - 1] + a[i];
    }

    unordered_map<int, int> diff; 
    int ans = 0;

    diff[0] = 0;


    for (int i = 1; i <= n; i++)
    {
        if (diff.find(qz[i]) != diff.end())
        {

            ans = max(ans, i - diff[qz[i]]);
        }
        else
        {

            diff[qz[i]] = i;
        }
    }

    cout << ans << endl;
    return 0;
}

```

### 主要

> 一句话，如果数组中只有两个数x,y;且x+y=0。那么如果前缀和数组中`qz[i]==qz[j]`，则在i-j这个区间中x与y的数目相同。

```cpp

    unordered_map<int, int> diff; 
    int ans = 0;

    diff[0] = 0;


    for (int i = 1; i <= n; i++)
    {
        if (diff.find(qz[i]) != diff.end())
        {

            ans = max(ans, i - diff[qz[i]]);
        }
        else
        {

            diff[qz[i]] = i;
        }
    }
```

### 解释：前缀和与子数组男女人数相等

在这段代码中，`qz[i]` 表示从数组的第一个元素到第 `i` 个元素的前缀和，而前缀和的计算规则是：我们将男生视作 `+1`，女生视作 `-1`，然后计算当前位置 `i` 之前的累加值。

### 问题背景

我们希望找到一个子数组，使得该子数组中的男生和女生数量相等。为了方便计算，我们把每个男生记为 `1`，每个女生记为 `-1`。这样，如果某一段子数组的男生和女生数量相等，那么该子数组的前缀和就为 0，或者该子数组的前缀和相同的情况发生过。

### **前缀和的定义**

- `qz[i]`：表示从数组的第 1 个元素到第 `i` 个元素的前缀和。
- 每次我们计算一个新的元素时，`qz[i]` 会是前 `i-1` 个元素的和加上当前元素。如果当前元素是男生（记作 `1`），那么 `qz[i] = qz[i-1] + 1`；如果当前元素是女生（记作 `-1`），那么 `qz[i] = qz[i-1] - 1`。

### 关键概念：相同前缀和的意义

#### 1. 前缀和相等的情况

假设我们有一个子数组 `arr[j..i]`，我们想知道这个子数组中的男生和女生数量是否相等。如果我们能找到一个 `j`，使得 `qz[j-1] == qz[i]`，那么 `qz[i] - qz[j-1]` 的差值为零，表示从位置 `j` 到 `i` 的子数组的男生和女生数量相等。

- **举个例子**： 假设我们有以下数组：`[0, 1, 0, 0, 1, 0]`，其中 `0` 表示女生，`1` 表示男生。

	我们对其进行转换，`0 -> -1`（女生），`1 -> +1`（男生），得到转换后的数组：`[-1, 1, -1, -1, 1, -1]`。

	对应的前缀和 `qz[i]`（表示前 `i` 个元素的累加和）如下：

	```
    i:    1  2  3  4  5  6
    arr: [-1  1 -1 -1  1 -1]
    qz:  [-1  0 -1 -2 -1 -2]
    ```

	- `qz[2] = 0` 表示从位置 1 到位置 2（包含）这个子数组的前缀和为零，这意味着男生和女生数量相等。
	- `qz[4] = -2`，表示从位置 1 到位置 4（包含）男生和女生的数量不相等。
	- `qz[6] = -2`，表示从位置 1 到位置 6（包含）男生和女生的数量也不相等。

#### 2. **前缀和相等的结论**

如果前缀和在两个不同的位置相等，假设在位置 `i` 和位置 `j` 处，`qz[i] == qz[j]`，那么从 `i+1` 到 `j` 的子数组的前缀和为零，也就意味着该子数组中男生和女生的数量相等。为什么？

- `qz[i]` 代表从开始到位置 `i` 的前缀和，`qz[j]` 代表从开始到位置 `j` 的前缀和（`j > i`）。如果这两个前缀和相等，意味着从 `i+1` 到 `j` 的部分和为零。
- 因为：  
	`qz[j] - qz[i] = 0`  
	也就表示 `arr[i+1]` 到 `arr[j]` 中的男生和女生数量相等。

### 代码中如何实现

在代码中，我们使用了一个哈希表（`unordered_map`）`diff` 来记录前缀和第一次出现的位置。具体来说：

1. 初始时，我们将 `qz[0] = 0` 存入哈希表，表示在前 `0` 个元素（即空子数组）的前缀和为 `0`。
2. 然后，我们遍历每个 `i`（从 `1` 到 `n`），对于每个 `i`：
	- 如果 `qz[i]` 已经存在于哈希表中，表示在之前的某个位置 `j` 也出现过相同的前缀和。那么，从位置 `j+1` 到位置 `i` 之间的子数组男女人数相等，长度为 `i - diff[qz[i]]`，我们可以更新答案。
	- 如果 `qz[i]` 没有出现过，说明这是第一次遇到这个前缀和，我们将 `qz[i]` 和位置 `i` 存入哈希表，以便后续可能会用到。

### 例子演示

假设我们有一个数组：

```
9
0 1 0 0 0 1 1 0 0
```

- 经过转换得到：`[-1, 1, -1, -1, -1, 1, 1, -1, -1]`，前缀和 `qz` 如下：

	```
    i:    1  2  3  4  5  6  7  8  9
    arr: [-1  1 -1 -1 -1  1  1 -1 -1]
    qz:  [-1  0 -1 -2 -3 -2 -1 -2 -3]
    ```

- 当遍历到 `i=6`，我们发现 `qz[6] = -2` 在哈希表中已经存在，说明从 `i=2` 到 `i=6` 之间的子数组男女人数相等，长度为 `6 - 2 = 4`。
	
- 此时我们更新答案为 `4`。

最终输出结果为：

```
6
```

### 总结

- 如果前缀和在不同的位置相等，说明这两个位置之间的子数组中的男生和女生数量相等。
- 使用哈希表记录前缀和及其第一次出现的位置，能有效地找到满足条件的最长子数组。
