### 优化因子计数算法 —— 类似埃拉托斯特尼筛法

#### **问题描述：**

计算从 1 到 n 中所有数字的因子总数。对于每个数字 j，我们需要计算它的所有因子，并将其累加。

#### **思路分析：**

直接对于每个数字 j 逐个判断它的因子是比较低效的，时间复杂度较高。为了提高效率，我们可以利用类似 **埃拉托斯特尼筛法** 的思想，进行优化。通过如下方法，能够将时间复杂度从 )$O(n^2)$ 降低到 $O(n \log n)$。

#### **优化思路：**

1. **预计算每个数字的因子个数**：
    
    - 对于每个 i 从 1 到 n，它是所有 i 的倍数的因子。所以，我们可以将 i 添加到它的每个倍数的因子计数中。
2. **筛法**：
    
    - 我们类似于埃拉托斯特尼筛法的思路，对于每个 i，遍历所有 i 的倍数$（即 i,2i,3i,…i, 2i, 3i, \dots）$，并对这些倍数的因子计数加 1。
3. **最终结果**：
    
    - 遍历完成后，每个数的因子个数都被正确计算并存储在一个数组中，最后我们将所有数字的因子个数相加，得到结果。

#### **重要步骤及代码实现：**

1. **初始化因子计数数组**：
    
    - 创建一个数组 `num`，其中 `num[i]` 记录数字 i 的因子数量。初始化为 0。
2. **筛法进行因子计数**：
    
    - 遍历每个 i，对于每个 i，将它的倍数$（i,2i,3i,…i, 2i, 3i, \dots）$的因子计数加 1。
3. **计算总和**：
    
    - 遍历整个数组，累加所有数字的因子数量，得到最终的答案。

#### **优化后的代码：**

```cpp
#include <iostream>

using namespace std;

typedef long long ll;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    ll n;
    cin >> n;
    ll ans = 0;

    // 用一个数组来存储每个数字的因子个数
    ll num[n + 1] = {0};

    // 类似埃拉托斯特尼筛法
    for (ll i = 1; i <= n; i++) {
        for (ll j = i; j <= n; j += i) {
            num[j]++;  // i 是 j 的因子
        }
    }

    // 计算所有数字的因子个数总和
    for (ll i = 1; i <= n; i++) {
        ans += num[i];
    }

    cout << ans << endl;

    return 0;
}
```

#### **代码详解：**

1. **初始化数组 `num`**：
    
    - `ll num[n + 1] = {0};`：定义一个大小为 n+1n+1 的数组 `num`，用于记录每个数字的因子数量。注意数组下标从 1 开始，所以数组大小为 n+1n+1。
2. **遍历每个 ii**：
    
    - 对于每个 ii 从 1 到 nn，我们遍历 ii 的倍数（i,2i,3i,…i, 2i, 3i, \dots），并将每个倍数的因子数量加 1。
3. **累加所有数字的因子数量**：
    
    - 在 `num` 数组填充完毕后，我们将 `num[i]` 累加，得到最终的因子总数。

#### **时间复杂度分析：**

- **外层循环**：遍历 ii 从 1 到 nn，即 O(n)O(n)。
- **内层循环**：对每个 ii，遍历 ii 的倍数，遍历次数是 O(n/i)O(n/i)。所以总时间复杂度是： O(n∑i=1n1i)=O(nlog⁡n)O\left(n \sum_{i=1}^{n} \frac{1}{i}\right) = O(n \log n) 这比直接遍历每个数字的因子（O(n2)O(n^2)）要高效得多。

